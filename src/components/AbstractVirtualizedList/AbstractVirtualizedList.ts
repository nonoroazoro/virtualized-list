import cs from "classnames";

import
{
    calculateAppendedItems,
    calculateLeadingRemovedElements,
    calculatePaddings,
    calculatePrependedItems,
    calculateRenderedIndexRange,
    calculateRenderRange,
    calculateTrailingRemovedElements,
    debounce,
    DEFAULT_SCROLL_TO_CONFIG,
    isRangeEqual,
    log,
    offsetRange,
    removeElements,
    writeItemDataset
} from "../../utils";
import { DEFAULT_LIST_CONFIG } from "./VirtualizedListConfig";
import { HTMLComponent } from "../HTMLComponent";
import { ItemDataManager } from "../../store";
import { ResizeTracker, ScrollTracker } from "../../trackers";
import { ScrollManager } from "../../scroll";
import type { ItemData, RenderedIndexRange, RenderRange } from "../../types";
import type { ResizeTrackerEntry, ScrollTrackerEntry } from "../../trackers";
import type { ScrollOptionsSupported } from "../../scroll";
import type { VirtualizedListConfig } from "./VirtualizedListConfig";
import type { VirtualizedListEventTypes } from "./VirtualizedListEventTypes";
import type { VirtualizedListOptions } from "./VirtualizedListOptions";

import * as styles from "./AbstractVirtualizedList.less";

/**
 * Abstract virtualized list component.
 */
export abstract class AbstractVirtualizedList<DataType> extends HTMLComponent<VirtualizedListEventTypes>
{
    protected override _options: VirtualizedListConfig;

    private _itemDataManager: ItemDataManager<DataType>;
    private _scrollTracker: ScrollTracker;
    private _scrollableResizeTracker: ResizeTracker;
    private _itemsResizeTracker: ResizeTracker;
    private _scrollManager: ScrollManager;

    private _continueScrollToIndex: Function | undefined;

    private _renderRange: RenderRange = [0, 0];
    private _currentRenderedIndexRange: RenderedIndexRange | undefined;

    private _paddingTop = 0;
    private get paddingTop()
    {
        return this._paddingTop;
    }

    private set paddingTop(value: number)
    {
        this._paddingTop = value;
        this._itemsContainer.style.paddingTop = `${value}px`;
    }

    private _paddingBottom = 0;
    private get paddingBottom()
    {
        return this._paddingBottom;
    }

    private set paddingBottom(value: number)
    {
        this._paddingBottom = value;
        this._itemsContainer.style.paddingBottom = `${value}px`;
    }

    /**
     * Gets the options for the list.
     */
    public get options()
    {
        return this._options;
    }

    /**
     * Sets the data source of the list.
     *
     * This will trigger a re-render.
     */
    public set dataSource(value: DataType[])
    {
        // TODO:
        // 1. update data attributes and item data array when the data is changed.
        // 2. re-render.
        log("=== set data ===");
        this._itemDataManager.dataSource = value;
        this._render();
    }

    private _scrollableContainer: HTMLDivElement;
    /**
     * Gets the scrollable container element.
     */
    public get scrollableContainer(): HTMLDivElement
    {
        return this._scrollableContainer;
    }

    private _itemsContainer: HTMLDivElement;
    /**
     * Gets the items container element.
     */
    public get itemsContainer(): HTMLDivElement
    {
        return this._itemsContainer;
    }

    /**
     * Creates an instance of {@link AbstractVirtualizedList}.
     *
     * @param {VirtualizedListOptions} [options] The options for the list.
     */
    constructor(options?: VirtualizedListOptions)
    {
        super(
            "div",
            {
                ...DEFAULT_LIST_CONFIG,
                ...options,
                className: cs(styles.container, options?.className)
            }
        );
        this._init();
    }

    /**
     * Generates an unique identifier for the raw item data.
     *
     * @param {DataType} itemData The raw item data.
     * @returns Returns the unique identifier.
     */
    public abstract generateItemKey(itemData: DataType, index: number): string;

    /**
     * Renders a list item.
     *
     * @param {DataType} itemData The {@link ItemData} used to render the list item.
     * @param {string} key The unique identifier generated by {@link AbstractVirtualizedList.generateItemKey}.
     * @param {number} index The index of the {@link ItemData}.
     * @returns Returns the corresponding `HTMLElement`.
     */
    protected abstract renderListItem(itemData: DataType, key: string, index: number): HTMLElement;

    /**
     * Renders the empty state placeholder when the list has no items.
     *
     * @returns Returns the corresponding `HTMLElement`.
     */
    protected renderListEmpty(): HTMLElement | undefined { return; }

    /**
     * Renders the list header.
     *
     * @returns Returns the corresponding `HTMLElement`.
     */
    protected renderListHeader(): HTMLElement | undefined { return; }

    /**
     * Renders the list footer.
     *
     * @returns Returns the corresponding `HTMLElement`.
     */
    protected renderListFooter(): HTMLElement | undefined { return; }

    public override appendTo(element: DocumentFragment | HTMLComponent | HTMLElement)
    {
        super.appendTo(element);
        this._render();
    }

    public override dispose()
    {
        this._clearInProgressScroll();

        this._itemDataManager.dispose();

        this._scrollTracker.dispose();
        this._scrollableResizeTracker.dispose();
        this._itemsResizeTracker.dispose();
        this._scrollManager.dispose();

        super.dispose();
    }

    //#region Scroll
    /**
     * Scrolls to the position.
     *
     * @param {number} position The pixels along the y-axis.
     * @param {boolean} [isSmooth] Specifies whether to enable smooth scroll.
     */
    scrollTo(position: number, isSmooth?: ScrollOptionsSupported["isSmooth"])
    {
        this._clearInProgressScroll();
        this._scrollManager.scrollTo(position, isSmooth == null ? undefined : { isSmooth });
    }

    /**
     * Scrolls to top.
     *
     * @param {boolean} [isSmooth] Specifies whether to enable smooth scroll.
     */
    public scrollToTop(isSmooth: ScrollOptionsSupported["isSmooth"] = false)
    {
        this.scrollToIndex(0, { isSmooth });
    }

    /**
     * Scrolls to bottom.
     *
     * @param {boolean} [isSmooth] Specifies whether to enable smooth scroll.
     */
    public scrollToBottom(isSmooth: ScrollOptionsSupported["isSmooth"] = false)
    {
        this.scrollToIndex(this._itemDataManager.dataSourceLength - 1, { isSmooth });
    }

    /**
     * Scrolls to the item at the specified index.
     *
     * @param {number} index The item index.
     * @param {ScrollOptionsSupported} [options] The scroll options.
     */
    public scrollToIndex(index: number, options?: ScrollOptionsSupported)
    {
        let narrowedIndex = Math.min(index, this._itemDataManager.dataSourceLength - 1);
        narrowedIndex = Math.max(0, narrowedIndex);

        const position = this._itemDataManager.getItemOffset(narrowedIndex);
        let offsetTop = position[0];
        if (options != null)
        {
            if (options.alignment === "center")
            {
                // Align to the center of the scrollable container.
                offsetTop -= (this._scrollableContainer.clientHeight - position[1]) / 2;
            }
            else if (options.alignment === "end")
            {
                // Align to the end of the scrollable container.
                offsetTop -= (this._scrollableContainer.clientHeight - position[1]);
            }
        }

        // Set in-progress scroll.
        this._continueScrollToIndex = this.scrollToIndex.bind(this, index, options);

        // Start scrolling.
        this._scrollManager.scrollTo(offsetTop, options);
    }
    //#endregion

    private _init()
    {
        // Create scrollable container.
        this._scrollableContainer = this.createElement("div", styles.scrollableContainer);

        // Create items container.
        this._itemsContainer = this.createElement("div", styles.itemsContainer);

        // Commit.
        this._scrollableContainer.appendChild(this._itemsContainer);
        this.appendChild(this._scrollableContainer);

        // Init ItemDataManager.
        this._itemDataManager = new ItemDataManager(this);

        // Init ScrollTracker.
        this._scrollTracker = new ScrollTracker(this._scrollableContainer);
        this._scrollTracker.on("scroll", this._handleScroll);
        this._scrollTracker.on("scrollChange", this._handleScrollChange);
        this._scrollTracker.on("topReached", this._handleTopReached);
        this._scrollTracker.on("bottomReached", this._handleBottomReached);
        this._scrollTracker.observe();

        // Init ScrollableResizeTracker.
        this._scrollableResizeTracker = new ResizeTracker(this._handleScrollableResize);
        this._scrollableResizeTracker.observe(this._scrollableContainer);

        // Init ItemsResizeTracker.
        this._itemsResizeTracker = new ResizeTracker(this._handleItemsResize);

        // Init ScrollManager.
        this._scrollManager = new ScrollManager(this._scrollableContainer);
        this._handleScrollEnd = debounce(this._handleScrollEnd, DEFAULT_SCROLL_TO_CONFIG.duration);
    }

    private _clear()
    {
        this._removeItemElements(this._itemsContainer.children);
    }

    /**
     * Initializes the list items.
     */
    private _render()
    {
        // Render after the list container is isAppended.
        if (this._isAppended)
        {
            // TODO: add diff and re-render.
            // If we have a way to diff the data, we can bypass this clear function.
            const scrollTop = this._scrollableContainer.scrollTop;
            this._clear();

            log("=== reconcile: Render");
            this._reconcileItems(scrollTop);
        }
    }

    private _handleScrollableResize = (entries: ResizeTrackerEntry[]) =>
    {
        // Update the render range.
        const renderRange = calculateRenderRange(
            this._options.leadingBufferZone,
            this._options.trailingBufferZone,
            entries[0].contentHeight
        );
        if (!isRangeEqual(this._renderRange, renderRange))
        {
            this._renderRange = renderRange;
            log("=== reconcile: Scrollable Resize");
            this._reconcileItems(this._scrollableContainer.scrollTop);
        }
    };

    private _handleItemsResize = (entries: ResizeTrackerEntry[]) =>
    {
        // 1. Updates items' height and calculates the total height difference.
        const delta = entries.reduce(
            (acc, entry) => acc + this._itemDataManager.updateItemHeight(entry.target, entry.contentHeight),
            0
        );

        // 2. Reconcile items.
        log("=== reconcile: Items Resize");
        this._reconcileItems(this._scrollableContainer.scrollTop);

        // 3. Due to the items resizing, we need to continue the in-progress scroll.
        // This will fix the scrollToIndex method.
        if (delta !== 0 && this._continueScrollToIndex)
        {
            this._continueScrollToIndex();
        }
    };

    private _handleScroll = (entry: ScrollTrackerEntry) =>
    {
        this.emit("scroll", entry);

        // Reconcile items while scrolling.
        log("=== reconcile: Scroll");
        this._reconcileItems(entry.scrollTop);
    };

    private _handleScrollChange = (isScrolling: boolean) =>
    {
        if (!isScrolling)
        {
            this._handleScrollEnd();
        }
        this.emit("scrollChange", isScrolling);
    };

    private _handleTopReached = () =>
    {
        this.emit("topReached");
    };

    private _handleBottomReached = () =>
    {
        this.emit("bottomReached");
    };

    /**
     * Note: This method is debounced.
     */
    private _handleScrollEnd = () =>
    {
        this._clearInProgressScroll();
    };

    /**
     * Conciliates the items rendered in the list.
     *
     * Note: This method will adds/removes items and update paddings.
     */
    private _reconcileItems(scrollTop: number)
    {
        let prependedItems: Array<ItemData<DataType>> = [];
        let appendedItems: Array<ItemData<DataType>> = [];
        let leadingRemoved: HTMLElement[] = [];
        let trailingRemoved: HTMLElement[] = [];

        // Calculates the offset render range.
        const offsetRenderRange = offsetRange(this._renderRange, scrollTop);
        if (this._itemsContainer.childElementCount > 0)
        {
            const [renderRangeTop, renderRangeBottom] = offsetRenderRange;

            // 1. Calculates items that should be preprened.
            prependedItems = calculatePrependedItems(
                offsetRenderRange,
                this._itemsContainer.firstElementChild as HTMLElement,
                this._itemDataManager
            );

            // 2. Calculates items that should be appended.
            appendedItems = calculateAppendedItems(
                offsetRenderRange,
                this._itemsContainer.lastElementChild as HTMLElement,
                this._itemDataManager
            );

            // 3. Calculates items that should be removed from the leading side of the list.
            if (prependedItems.length === 0)
            {
                // Bypassed if scroll up or we are about to prepend items.
                leadingRemoved = calculateLeadingRemovedElements(renderRangeTop, this._itemsContainer);
            }

            // 4. Calculates items that should be removed from the trailing side of the list.
            if (appendedItems.length === 0)
            {
                // Bypassed if scroll down or we are about to append items.
                trailingRemoved = calculateTrailingRemovedElements(renderRangeBottom, this._itemsContainer);
            }
        }
        else
        {
            // 5. Calculates items from the scratch.
            appendedItems = this._itemDataManager.getItemsByRange(offsetRenderRange);
        }

        log("prependedItems", prependedItems);
        log("appendedItems", appendedItems);
        log("leadingRemoved", leadingRemoved);
        log("trailingRemoved", trailingRemoved);

        // 5. Remove elements.
        this._removeItemElements(leadingRemoved);
        this._removeItemElements(trailingRemoved);

        // 6. Render items.
        this._itemsContainer.append(...appendedItems.map(itemData => this._createItemElement(itemData)));
        this._itemsContainer.prepend(...prependedItems.map(itemData => this._createItemElement(itemData)));

        // 7. Update paddings to make up scrollHeight.
        this._updatePaddings();
    }

    private _updatePaddings()
    {
        const nextRenderedIndexRange = calculateRenderedIndexRange(this._itemsContainer);
        if (nextRenderedIndexRange == null)
        {
            log("=== update paddings: clear ===");
            // 1. Clear paddings.
            this.paddingTop = 0;
            this.paddingBottom = 0;
        }
        else if (this._currentRenderedIndexRange == null)
        {
            log("=== update paddings: rebuild ===");
            // 2. Build the paddings `from the scratch`.
            // Note: This is an `expensive operation`, should never be called frequently.
            const { paddingTop, paddingBottom } = calculatePaddings(nextRenderedIndexRange, this._itemDataManager);
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
        }
        else if (!isRangeEqual(this._currentRenderedIndexRange, nextRenderedIndexRange))
        {
            // 3. Update paddings incrementally.
            log("=== update paddings: incremental ===", this._currentRenderedIndexRange, "=>", nextRenderedIndexRange);

            // Calculates padding top.
            let deltaPaddingTop = 0;
            let sign = 1;
            let start = this._currentRenderedIndexRange[0];
            let end = nextRenderedIndexRange[0];
            if (end < start)
            {
                // Swap.
                sign *= -1;
                end = start;
                start = nextRenderedIndexRange[0];
            }
            // [start, end)
            for (let i = start; i < end; i++)
            {
                deltaPaddingTop += this._itemDataManager.getItem(i).height;
            }
            deltaPaddingTop *= sign;

            // Calculates padding bottom.
            let deltaPaddingBottom = 0;
            sign = -1;
            start = this._currentRenderedIndexRange[1];
            end = nextRenderedIndexRange[1];
            if (end < start)
            {
                // Swap.
                sign *= -1;
                end = start;
                start = nextRenderedIndexRange[1];
            }
            // (start, end]
            for (let i = start + 1; i <= end; i++)
            {
                deltaPaddingBottom += this._itemDataManager.getItem(i).height;
            }
            deltaPaddingBottom *= sign;

            log("=== update paddings: delta ===", deltaPaddingTop, deltaPaddingBottom);
            if (deltaPaddingTop !== 0)
            {
                this.paddingTop += deltaPaddingTop;
            }

            if (deltaPaddingBottom !== 0)
            {
                this.paddingBottom += deltaPaddingBottom;
            }
        }
        this._currentRenderedIndexRange = nextRenderedIndexRange;
    }

    private _createItemElement(itemData: ItemData<DataType>)
    {
        const element = this.createElement("div", styles.listItem);
        element.appendChild(this.renderListItem(
            itemData.data,
            itemData.key,
            itemData.index
        ));
        writeItemDataset(element, itemData);
        this._itemsResizeTracker.observe(element);
        return element;
    }

    private _removeItemElements(elements: HTMLCollection | HTMLElement[])
    {
        removeElements(elements, (element: HTMLElement) =>
        {
            this._itemsResizeTracker.unobserve(element);
        });
    }

    private _clearInProgressScroll()
    {
        this._continueScrollToIndex = undefined;
    }
}
